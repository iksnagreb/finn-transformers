stages:
  - build

variables:
  # Ort der virtuellen Umgebung
  VENV_PATH: "/data/gitlab/builds/runner/.venv"

build:
  stage: build
  script:
    # 1. Verzeichnis anlegen
    - mkdir -p /data/gitlab/builds/runner
    # 2. Virtuelle Umgebung erstellen
    - rm -rf $VENV_PATH        # alte venv löschen
    - python3 -m venv $VENV_PATH
    # 3. venv aktivieren
    - source $VENV_PATH/bin/activate
    # 4. pip upgraden und Dependencies installieren

    - export CUDA_ROOT=/usr/local/cuda
    - export CFLAGS="-I/usr/local/cuda/include"
    - export CXXFLAGS="-I/usr/local/cuda/include"
    - export C_INCLUDE_PATH=/usr/local/cuda/include
    - export CPLUS_INCLUDE_PATH=/usr/local/cuda/include
    - export LIBRARY_PATH=/usr/local/cuda/lib64
    # - export LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH
    # - export LD_LIBRARY_PATH="/usr/lib/aarch64-linux-gnu:$LD_LIBRARY_PATH"
    - export LD_LIBRARY_PATH=/usr/local/cuda/lib64:/usr/lib/aarch64-linux-gnu:$LD_LIBRARY_PATH

    - export PYTHONPATH="/usr/lib/python3/dist-packages:/usr/lib/python3.8/dist-packages:$PYTHONPATH"


    - ls -l /usr/local/cuda/include/cuda.h
    - pip install --upgrade pip
    - pip install torch==2.6.0 torchvision torchaudio --index-url https://download.pytorch.org/whl/test/cu126 -q
    - pip install --no-cache-dir -r requirements.txt
    # 5. Optional: testen, ob alles funktioniert
    - python -c "import sys; print('Pytho version:', sys.version, flush = True)"
    - which python3
    - python3 --version
    - python3 -c "import sys; print(sys.path)"
    - python3 -c "import tensorrt; print(tensorrt.__version__)"
    - python3 measure/mini_measure.py
  tags:
    - jetson

# stages:
#   - test
# hello_world_job:
#   stage: test
#   script:
#     - source /home/hanna/git/measure-radioml/venv/bin/activate
#     - 'which ssh-agent || ( apt-get update -y && apt-get install openssh-client -y )'
#     - eval $(ssh-agent -s)
#     - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
#     - mkdir -p ~/.ssh
#     - ssh-keyscan gitlab.com >> ~/.ssh/known_hosts
#     - dvc remote list
#     - dvc remote modify sciebo user $DVC_Sciebo_USER
#     - dvc remote modify sciebo password $DVC_Sciebo_PASSWORD
#     - dvc pull
#     - python measure/mini_measure.py
#     - dvc push
#     - dvc exp push -r sciebo -f git@gitlab.com:hanner123-group/gitlab_runner.git
#   tags:
#     - jetson

# stages:
#   - test
# hello_world_job:
#   stage: test
#   script:
#     - echo "Runner läuft!!"


# wichtig: richtige uni git domain, nur ein runner im toml
# runner restart mit: sudo systemctl restart gitlab-runner
# toml bearbeiten: sudo nano /etc/gitlab-runner/config.toml
# logs anschauen: sudo journalctl -u gitlab-runner -f
# pipeline im train-measure branch manuell starten - manuell commit machen, damit die pipeline gefunden werden kann
# kompliziertere pipeline testen
# pipeline mit measure testen
# dvc live einrichten
# sudo chown -R gitlab-runner:gitlab-runner /data/gitlab/builds/runner/
# probleme bei pycuda installation -> erstmal weglassen
# es dauert wieder so lange bis der mirror aktualisiert ist... wieso? weil vorher ein richtiger commit gemacht wurde Funktiniert dann der pull mirror nicht mehr? -> force push und reset (ausversehen zu measure_jetson, noch richtig machen!!)
# dauert schon wieder so lange? - hard reset

# kein cuda verfügbar! wahrscheinlic weil das environment nicht ganz gesäubert wurde -> gucken wo ich das einstellen kann (venv soll nicht übernommen werden von altem build!)
# clean = true im toml setzen

# irgendwie löscht er das nicht richtig -> manuell die inhalte der ordner löschen
# dann runner restarten

# warum funktioniert cuda trotzdem nicht? noch nicht ganz gesäubert oder so... vielleicht doch noch alten runner austesten? Was war anders?
# sudo usermod -aG video,render gitlab-runner
# es funktioniert endlich! aber nach stop tegrastats läuft es trotzdem zu lange...
# gitlab-runner ALL=(ALL) NOPASSWD:ALL war noch drin
# test: tegrastats ohne sudo??
# klappt endlich, jetzt: mehr requirements hinzufügen




# # Lokales Klonen des Mirror-Repos
# git clone <mirror-repo-url> mirror-local
# cd mirror-local

# # Füge das GitHub-Repo als Remote hinzu
# git remote add upstream <github-repo-url>

# # Hole den aktuellen Stand vom GitHub-Repo
# git fetch upstream

# # Setze den Branch auf den GitHub-Stand
# git checkout main
# git reset --hard upstream/main

# # Push zurück zum Mirror (force!)
# git push origin main --force


# training nicht                neu mache, einfach vom main die models nehmen

# qcdq export parameter statt qonnx qcdq verwenden
# def export(model, dataset, batch_size, format="qcdq", split_heads=False,) batch size 
# name immer model.onnx